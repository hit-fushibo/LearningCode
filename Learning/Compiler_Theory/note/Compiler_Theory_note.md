# 24 春编译原理笔记

## 第一章 绪论

### 1.1 什么是编译

- 高级语言

  - 接近人类表达习惯
  - 不依赖于特定机器
  - 编写效率高
- 汇编语言

  - 依赖于特定机器
  - 编写效率依然很低
- 机器语言

  - 与人类表达习惯相差很大
  - 难记忆
  - 难编写、阅读
  - 易写错

![1709699421936](images/1709699421936.png)

**编译**：将高级语言翻译成汇编语言或者机器语言的过程

### 1.2 编译系统的结构

编译器的结构

- 分析部分：与源语言有关
  - 词法分析器
    - 字符流->词法单元流
  - 语法分析器
    - 词法单元流->语法树
  - 语义分析器
    - 语法树->语法树
  - 中间代码生成器
    - 语法树->中间表示形式
- 机器无关代码优化器
  - 中间表示形式->中间表示形式
- 综合部分：与目标语言有关
  - 目标代码生成器
    - 中间表示形式->目标机器语言
  - 机器相关代码优化器
    - 目标机器语言->目标机器语言

词法分析

- 主要任务：从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示——词法单元(token：<种别码，属性值>)形式
- token
  - 关键字：一词一码
  - 标识符：多词一码
  - 常量：一型一码
  - 运算符：一词一码或一型一码
  - 界限符：一词一码

语法分析

- 主要任务：从词法分析器输出的 token 序列中识别出各类短语，并构造语法分析树

  ![1709700126964](images/1709700126964.png)

语义分析

- 主要任务

  - 收集标识符的属性信息：种属、类型、存储位置和长度、值、作用域、参数和返回值信息（参数个数、类型、传递方式、返回值类型）。收集的信息存储在符号表中
  - 语义检查

    ![1709700300118](images/1709700300118.png)

常用的中间表示形式

- 三地址码：由类似于汇编语言的指令序列组成，每个指令最多有三个操作数
  - 三地址指令的表示形式
    - 四元式：(op,arg1,arg2,result)
    - 三元式：(op.arg1,arg2)
    - 间接三元式
  - 地址形式
    - 源程序中的名字
    - 常量
    - 编译器生成的临时变量
  - 三地址指令序列唯一确定了运算完成的顺序
- 语法结构树、语法树

目标代码生成

- 以源程序的中间表示形式作为输入，并把它映射到目标语言
- 一个重要任务：为程序中使用的变量合理分配寄存器

代码优化

- 为改进代码所进行的等价程序变换，使其运行得更快一些、占用空间更少一些，或者二者兼顾

### 1.3 编译程序的生成

**机器语言编写**：

- 更好的发挥硬件系统的效率
- 可读性、可靠性、可维护性、编制效率差

**自展技术**：用高级语言编写

- T 形图
  ![1709700850403](images/1709700850403.png)
- 运用自展技术在同一台机器上实现不同语言的编译器
  ![1709700903941](images/1709700903941.png)

**编译器的移植**：有时也称为交叉编译，是指将一台机器上运行的编译器进行处理，构造出在另一台机器上可以运行的编译器

![1709700959671](images/1709700959671.png)

**编译器自动生成**：

- LEX：词法分析程序生成器
- YACC：语法分析程序生成器

## 第二章 语言及其文法

### 2.1 基本概念

串

- 一个有穷符号序列
- 一个串$s$的长度，通常记作$|s|$，指$s$中符号的个数
- 空串，长度为 0 的串，用$\epsilon$表示，其长度为 0
- 运算
  - 连接
    - 空串是连接运算的单位元
    - 设$x,y,z$是三个字符串，如果$z=xy$，则称$x$是$z$的前缀，$y$是 z 的后缀
  - 幂
    - $\begin{cases}s^0=\epsilon \\ s^n=s^{n-1}s \end{cases}$

字母表$\Sigma$

- 一个有穷符号集合
- 运算
  - 两个字母表$\Sigma_1$和$\Sigma_2$的**乘积**
    - $\Sigma_1 \Sigma_2=\{ab|a\in\Sigma_1,b\in\Sigma_2 \}$
  - 字母表$\Sigma$的 n 次幂
    - $ \begin{cases} \Sigma^0=\{\epsilon \} \\ \Sigma^n=\Sigma^{n-1}\Sigma ,n\leq 1 \end{cases} $
    - 由字母表中元素构成的长度为 n 的符号串的集合
  - 字母表$\Sigma$的正闭包
    - $\Sigma^+=\Sigma \cup\Sigma^2\cup\Sigma^3\cup\dots $
    - 长度为正数的符号串的集合
  - 字母表$\Sigma$的克林闭包
    - $\Sigma^\*=\Sigma^0\cup\Sigma^+ $
    - 任意符号串的集合

### 2.2 文法的定义

文法的形式化定义

- $G=(V_T,V_N,P,S)$
  - $V_T$：终结符集合
    - 终结符是文法所定义的语言的基本符号，有时也称为 token
  - $V_N$：非终结符集合
    - 非终结符是用来表示语法成分的变量，有时也称为*语法变量*
  - $P$：产生式集合
    - 产生式描述了将终结符和非终结符组合成串的方法
    - 产生式的一般形式：$\alpha\rightarrow\beta$
      - $\alpha\in (V_T\cup V_N)^+ $，且$\alpha$中至少包含一个$V_N$中的元素：称为产生式的**头部**或**左部**
      - $\beta \in (V_T\cup V_N )^*$，称为产生式的**体**或**右部**
    - 产生式的简写
      - 对于一组有相同左部的$\alpha$产生式$\alpha\rightarrow\beta_1,\alpha\rightarrow\beta_2,\dots $可以简记为$\alpha\rightarrow\beta_1|\beta_2|\dots$
      - $\beta_1,\beta_2,\dots$称为$\alpha$的候选式
  - $S$：开始符号
    - $S\in V_N$，开始符号表示该文发中最大的语法成分

符号约定

![1709810797257](images/1709810797257.png)

![1709810808236](images/1709810808236.png)

![1709810822832](images/1709810822832.png)

### 2.3 语言的定义

推导和规约-*和形式语言差不多*

![1709810995562](images/1709810995562.png)

![1709811006306](images/1709811006306.png)

![1709811034790](images/1709811034790.png)

如何判定某一词串是否为该语言的句子

- 句子的推导
- 句子的规约

句型和句子

- 句型

  ![1709811116309](images/1709811116309.png)

  - 句型中可以包含终结符和非终结符，也可能为空串
- 句子是不包含非终结符的句型

语言的形式化定义

- 由文法$G$的开始符号$S$推导出的所有句子构成的集合称为文法$G$生成的语言，记为$L(G)$，即$L(G)=\{ w|S\Rightarrow^*w,w\in {V_T}^* \}$

语言上的运算

![1709811341139](images/1709811341139.png)

### 2.3 文法的分类

Chomsky 文法分类体系

- 0 型文法
  - 无限制文法/短语结构文法
  - $\forall \alpha\rightarrow\beta\in P $，$\alpha$中至少包含一个非终结符
- 1 型文法
  - 上下文有关文法 CSG
  - $\forall \alpha\rightarrow\beta\in P,|\alpha |\leq|\beta |$
  - 产生式的一般形式：$\alpha_1A\alpha_2\rightarrow\alpha_1\beta\alpha_2(\beta\neq\epsilon )$
  - 不包含$\epsilon$-表达式
- 2 型文法
  - 上下文无关文法 CFG
  - $\forall \alpha\rightarrow\beta\in P,\alpha\in V_N$
  - 产生式的一般形式：$A\rightarrow\beta$
- 3 型文法
  - 正则文法
  - 右线性文法：$A\rightarrow wB$或$A\rightarrow w$
  - 左线性文法：$A\rightarrow Bw$或$A\rightarrow w$
  - 左线性文法和右线性文法都称为正则文法
  - 正则文法能描述程序设计语言的多数单词

四种文法的关系

![1709812100082](images/1709812100082.png)

### 2.5 CFG 的分析树

![1709812144039](images/1709812144039.png)

![1709812159541](images/1709812159541.png)

![1709812171083](images/1709812171083.png)

直接短语一定是某产生式的右部，但是产生式的右部不一定都是给定句型的直接短语

二义性文法：如果一个文法的某个句子可以生成多颗分析树，则称该文法是二义性的

![1709812260683](images/1709812260683.png)

## 第三章 词法分析

### 3.1 单词的描述

正则文法

![1710068608110](images/1710068608110.png)

正则表达式：一种用来描述正则语言更紧凑的方法

![1710068623632](images/1710068623632.png)

正则定义

- 具有如下形式的定义序列

  ![1710068672946](images/1710068672946.png)
- 其中每个$d_i$都是一个**新符号**，它们都不在字母表$\Sigma$中，且**各不相同**
- 每个$r_i$都是字母表$\Sigma\cup \{d_1,d_2,\dots,d_{i-1}\}$上的正则表达式

### 3.2 单词的识别

有穷自动机（FA）

- 对一类处理系统建立的数学模型
- 该类系统具有一系列离散的输入输出信息和有穷数目的内部状态
- 系统根据当前状态和当前输入信息决定系统的后继行为
- 系统处理当前输入后内部状态也将发生改变

FA模型

- 输入带：用来存放符号串
- 读头：从左向右逐个读取输入符号不能修改，不能反向移动
- 有穷控制器：具有有穷个状态数，根据当前的状态和当前输入符号控制转入下一状态

FA的表示：转换图，这个自动机讲过

FA接收（定义）的语言：

- 给定输入串$x$，如果存在一个对应于串$x$从初始状态到某个终止状态的转换序列则称串$x$被该FA接收
- 由一个有穷自动机M接收的所有串构成的集合称为是该FA定义或接收的语言，记为$L(M)$

最长字串匹配原则

- 当输入串的多个前缀和一个或多个模式匹配时，总是选择最长的前缀进行匹配
- 在到达某个终态后，只要输入带上还有符号，FA就继续前进，以便寻找尽可能长的匹配

FA的分类

- 确定的FA：DFA

  - $M=(S,\Sigma,\delta,s_0,F )$
  - $S$：有穷状态集
  - $\Sigma$：输入字母表
  - $\delta$：$S\times \Sigma\rightarrow S$的函数，即转换函数
  - $s_0$：开始状态
  - $F$：终止状态集合
- 非确定的FA：NFA

  - $M=(S,\Sigma,\delta,s_0,F )$
  - $S$：有穷状态集
  - $\Sigma$：输入字母表
  - $\delta$：$S\times \Sigma\rightarrow 2^S$的函数，即转换函数
  - $s_0$：开始状态
  - $F$：终止状态集合
- 具有$\epsilon$-边的NFA

  - $M=(S,\Sigma,\delta,s_0,F )$
  - $S$：有穷状态集
  - $\Sigma$：输入字母表
  - $\delta$：$S\times \{\Sigma\cup\{\epsilon\} \}\rightarrow S$的函数，即转换函数
  - $s_0$：开始状态
  - $F$：终止状态集合

DFA与NFA具有等价性

![1710070072116](images/1710070072116.png)

- 转换方式：不断根据输入写输出，输出有可能是多个原始状态的集合，之后把这些新的状态集合作为新的状态重复前面的过程，直到没有新的状态集合出现为止。需要注意，但凡集合中包含原始的终止的状态，那么在转换的DFA中就是终止状态，开始状态不变
- 带空转移的NFA转换类似，就是在写输出集合时需要把空转移也考虑上

DFA算法实现

![1710070365983](images/1710070365983.png)

根据正则表达式构造NFA

![1710070399272](images/1710070399272.png)

### 3.3 词法分析阶段错误处理

词法错误的类型

- 单词拼写错误
- 非法字符

词法错误检测

- 如果当前状态与当前输入符号在转换表对应项中的信息为空，并且当前状态并非终止状态，则调用错误处理程序

错误处理

- 查找已扫描字符串中最后一个对应于某终态的字符
  - 如果找到了，则将该字符和前面的字符识别为一个单词。然后将输入指针退回到该字符，扫描器重新回到初始状态，继续识别下一个单词
  - 如果没有找到，则确定出错，采用错误恢复策略
- 错误恢复策略：最简单的策略：”恐慌模式“恢复
  - 从剩余字符中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符为止

### 3.4 词法分析器生成工具LEX

LEX的构成

- LEX语言
- LEX编译器

LEX工作方式

![1710070791042](images/1710070791042.png)

扫描器自动生成的意义

- 加快了分析器实现速度
  - 程序员只需在很高的模式层次上描述软件就可以依赖自动生成工具来生成详细的代码
- 修改扫描器的工作变得更加简单
  - 只用修改那些受到影响的模式，无需修改整个程序
