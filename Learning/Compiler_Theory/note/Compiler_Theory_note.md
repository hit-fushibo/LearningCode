<div STYLE="page-break-after: always;"></div>

# 24 春编译原理笔记

## 第一章 绪论

### 1.1 什么是编译

- 高级语言

  - 接近人类表达习惯
  - 不依赖于特定机器
  - 编写效率高
- 汇编语言

  - 依赖于特定机器
  - 编写效率依然很低
- 机器语言

  - 与人类表达习惯相差很大
  - 难记忆
  - 难编写、阅读
  - 易写错

![1709699421936](images/1709699421936.png)

**编译**：将高级语言翻译成汇编语言或者机器语言的过程

### 1.2 编译系统的结构

编译器的结构

- 分析部分：与源语言有关
  - 词法分析器
    - 字符流->词法单元流
  - 语法分析器
    - 词法单元流->语法树
  - 语义分析器
    - 语法树->语法树
  - 中间代码生成器
    - 语法树->中间表示形式
- 机器无关代码优化器
  - 中间表示形式->中间表示形式
- 综合部分：与目标语言有关
  - 目标代码生成器
    - 中间表示形式->目标机器语言
  - 机器相关代码优化器
    - 目标机器语言->目标机器语言

词法分析

- 主要任务：从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示——词法单元(token：<种别码，属性值>)形式
- token
  - 关键字：一词一码
  - 标识符：多词一码
  - 常量：一型一码
  - 运算符：一词一码或一型一码
  - 界限符：一词一码

语法分析

- 主要任务：从词法分析器输出的 token 序列中识别出各类短语，并构造语法分析树

  ![1709700126964](images/1709700126964.png)

语义分析

- 主要任务

  - 收集标识符的属性信息：种属、类型、存储位置和长度、值、作用域、参数和返回值信息（参数个数、类型、传递方式、返回值类型）。收集的信息存储在符号表中
  - 语义检查

    ![1709700300118](images/1709700300118.png)

常用的中间表示形式

- 三地址码：由类似于汇编语言的指令序列组成，每个指令最多有三个操作数
  - 三地址指令的表示形式
    - 四元式：(op,arg1,arg2,result)
    - 三元式：(op.arg1,arg2)
    - 间接三元式
  - 地址形式
    - 源程序中的名字
    - 常量
    - 编译器生成的临时变量
  - 三地址指令序列唯一确定了运算完成的顺序
- 语法结构树、语法树

目标代码生成

- 以源程序的中间表示形式作为输入，并把它映射到目标语言
- 一个重要任务：为程序中使用的变量合理分配寄存器

代码优化

- 为改进代码所进行的等价程序变换，使其运行得更快一些、占用空间更少一些，或者二者兼顾

### 1.3 编译程序的生成

**机器语言编写**：

- 更好的发挥硬件系统的效率
- 可读性、可靠性、可维护性、编制效率差

**自展技术**：用高级语言编写

- T 形图
  ![1709700850403](images/1709700850403.png)
- 运用自展技术在同一台机器上实现不同语言的编译器
  ![1709700903941](images/1709700903941.png)

**编译器的移植**：有时也称为交叉编译，是指将一台机器上运行的编译器进行处理，构造出在另一台机器上可以运行的编译器

![1709700959671](images/1709700959671.png)

**编译器自动生成**：

- LEX：词法分析程序生成器
- YACC：语法分析程序生成器

## 第二章 语言及其文法

### 2.1 基本概念

串

- 一个有穷符号序列
- 一个串$s$的长度，通常记作$|s|$，指$s$中符号的个数
- 空串，长度为 0 的串，用$\epsilon$表示，其长度为 0
- 运算
  - 连接
    - 空串是连接运算的单位元
    - 设$x,y,z$是三个字符串，如果$z=xy$，则称$x$是$z$的前缀，$y$是 z 的后缀
  - 幂
    - $\begin{cases}s^0=\epsilon \\ s^n=s^{n-1}s \end{cases}$

字母表$\Sigma$

- 一个有穷符号集合
- 运算
  - 两个字母表$\Sigma_1$和$\Sigma_2$的**乘积**
    - $\Sigma_1 \Sigma_2=\{ab|a\in\Sigma_1,b\in\Sigma_2 \}$
  - 字母表$\Sigma$的 n 次幂
    - $ \begin{cases} \Sigma^0=\{\epsilon \} \\ \Sigma^n=\Sigma^{n-1}\Sigma ,n\leq 1 \end{cases} $
    - 由字母表中元素构成的长度为 n 的符号串的集合
  - 字母表$\Sigma$的正闭包
    - $\Sigma^+=\Sigma \cup\Sigma^2\cup\Sigma^3\cup\dots $
    - 长度为正数的符号串的集合
  - 字母表$\Sigma$的克林闭包
    - $\Sigma^\*=\Sigma^0\cup\Sigma^+ $
    - 任意符号串的集合

### 2.2 文法的定义

文法的形式化定义

- $G=(V_T,V_N,P,S)$
  - $V_T$：终结符集合
    - 终结符是文法所定义的语言的基本符号，有时也称为 token
  - $V_N$：非终结符集合
    - 非终结符是用来表示语法成分的变量，有时也称为*语法变量*
  - $P$：产生式集合
    - 产生式描述了将终结符和非终结符组合成串的方法
    - 产生式的一般形式：$\alpha\rightarrow\beta$
      - $\alpha\in (V_T\cup V_N)^+ $，且$\alpha$中至少包含一个$V_N$中的元素：称为产生式的**头部**或**左部**
      - $\beta \in (V_T\cup V_N )^*$，称为产生式的**体**或**右部**
    - 产生式的简写
      - 对于一组有相同左部的$\alpha$产生式$\alpha\rightarrow\beta_1,\alpha\rightarrow\beta_2,\dots $可以简记为$\alpha\rightarrow\beta_1|\beta_2|\dots$
      - $\beta_1,\beta_2,\dots$称为$\alpha$的候选式
  - $S$：开始符号
    - $S\in V_N$，开始符号表示该文发中最大的语法成分

符号约定

![1709810797257](images/1709810797257.png)

![1709810808236](images/1709810808236.png)

![1709810822832](images/1709810822832.png)

### 2.3 语言的定义

推导和规约-*和形式语言差不多*

![1709810995562](images/1709810995562.png)

![1709811006306](images/1709811006306.png)

![1709811034790](images/1709811034790.png)

如何判定某一词串是否为该语言的句子

- 句子的推导
- 句子的规约

句型和句子

- 句型

  ![1709811116309](images/1709811116309.png)

  - 句型中可以包含终结符和非终结符，也可能为空串
- 句子是不包含非终结符的句型

语言的形式化定义

- 由文法$G$的开始符号$S$推导出的所有句子构成的集合称为文法$G$生成的语言，记为$L(G)$，即$L(G)=\{ w|S\Rightarrow^*w,w\in {V_T}^* \}$

语言上的运算

![1709811341139](images/1709811341139.png)

### 2.3 文法的分类

Chomsky 文法分类体系

- 0 型文法
  - 无限制文法/短语结构文法
  - $\forall \alpha\rightarrow\beta\in P $，$\alpha$中至少包含一个非终结符
- 1 型文法
  - 上下文有关文法 CSG
  - $\forall \alpha\rightarrow\beta\in P,|\alpha |\leq|\beta |$
  - 产生式的一般形式：$\alpha_1A\alpha_2\rightarrow\alpha_1\beta\alpha_2(\beta\neq\epsilon )$
  - 不包含$\epsilon$-表达式
- 2 型文法
  - 上下文无关文法 CFG
  - $\forall \alpha\rightarrow\beta\in P,\alpha\in V_N$
  - 产生式的一般形式：$A\rightarrow\beta$
- 3 型文法
  - 正则文法
  - 右线性文法：$A\rightarrow wB$或$A\rightarrow w$
  - 左线性文法：$A\rightarrow Bw$或$A\rightarrow w$
  - 左线性文法和右线性文法都称为正则文法
  - 正则文法能描述程序设计语言的多数单词

四种文法的关系

![1709812100082](images/1709812100082.png)

### 2.5 CFG 的分析树

![1709812144039](images/1709812144039.png)

![1709812159541](images/1709812159541.png)

![1709812171083](images/1709812171083.png)

直接短语一定是某产生式的右部，但是产生式的右部不一定都是给定句型的直接短语

二义性文法：如果一个文法的某个句子可以生成多颗分析树，则称该文法是二义性的

![1709812260683](images/1709812260683.png)

## 第三章 词法分析

### 3.1 单词的描述

正则文法

![1710068608110](images/1710068608110.png)

正则表达式：一种用来描述正则语言更紧凑的方法

![1710068623632](images/1710068623632.png)

正则定义

- 具有如下形式的定义序列

  ![1710068672946](images/1710068672946.png)
- 其中每个$d_i$都是一个**新符号**，它们都不在字母表$\Sigma$中，且**各不相同**
- 每个$r_i$都是字母表$\Sigma\cup \{d_1,d_2,\dots,d_{i-1}\}$上的正则表达式

### 3.2 单词的识别

有穷自动机（FA）

- 对一类处理系统建立的数学模型
- 该类系统具有一系列离散的输入输出信息和有穷数目的内部状态
- 系统根据当前状态和当前输入信息决定系统的后继行为
- 系统处理当前输入后内部状态也将发生改变

FA模型

- 输入带：用来存放符号串
- 读头：从左向右逐个读取输入符号不能修改，不能反向移动
- 有穷控制器：具有有穷个状态数，根据当前的状态和当前输入符号控制转入下一状态

FA的表示：转换图，这个自动机讲过

FA接收（定义）的语言：

- 给定输入串$x$，如果存在一个对应于串$x$从初始状态到某个终止状态的转换序列则称串$x$被该FA接收
- 由一个有穷自动机M接收的所有串构成的集合称为是该FA定义或接收的语言，记为$L(M)$

最长字串匹配原则

- 当输入串的多个前缀和一个或多个模式匹配时，总是选择最长的前缀进行匹配
- 在到达某个终态后，只要输入带上还有符号，FA就继续前进，以便寻找尽可能长的匹配

FA的分类

- 确定的FA：DFA

  - $M=(S,\Sigma,\delta,s_0,F )$
  - $S$：有穷状态集
  - $\Sigma$：输入字母表
  - $\delta$：$S\times \Sigma\rightarrow S$的函数，即转换函数
  - $s_0$：开始状态
  - $F$：终止状态集合
- 非确定的FA：NFA

  - $M=(S,\Sigma,\delta,s_0,F )$
  - $S$：有穷状态集
  - $\Sigma$：输入字母表
  - $\delta$：$S\times \Sigma\rightarrow 2^S$的函数，即转换函数
  - $s_0$：开始状态
  - $F$：终止状态集合
- 具有$\epsilon$-边的NFA

  - $M=(S,\Sigma,\delta,s_0,F )$
  - $S$：有穷状态集
  - $\Sigma$：输入字母表
  - $\delta$：$S\times \{\Sigma\cup\{\epsilon\} \}\rightarrow S$的函数，即转换函数
  - $s_0$：开始状态
  - $F$：终止状态集合

DFA与NFA具有等价性

![1710070072116](images/1710070072116.png)

- 转换方式：不断根据输入写输出，输出有可能是多个原始状态的集合，之后把这些新的状态集合作为新的状态重复前面的过程，直到没有新的状态集合出现为止。需要注意，但凡集合中包含原始的终止的状态，那么在转换的DFA中就是终止状态，开始状态不变
- 带空转移的NFA转换类似，就是在写输出集合时需要把空转移也考虑上

DFA算法实现

![1710070365983](images/1710070365983.png)

根据正则表达式构造NFA

![1710070399272](images/1710070399272.png)

### 3.3 词法分析阶段错误处理

词法错误的类型

- 单词拼写错误
- 非法字符

词法错误检测

- 如果当前状态与当前输入符号在转换表对应项中的信息为空，并且当前状态并非终止状态，则调用错误处理程序

错误处理

- 查找已扫描字符串中最后一个对应于某终态的字符
  - 如果找到了，则将该字符和前面的字符识别为一个单词。然后将输入指针退回到该字符，扫描器重新回到初始状态，继续识别下一个单词
  - 如果没有找到，则确定出错，采用错误恢复策略
- 错误恢复策略：最简单的策略：”恐慌模式“恢复
  - 从剩余字符中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符为止

### 3.4 词法分析器生成工具LEX

LEX的构成

- LEX语言
- LEX编译器

LEX工作方式

![1710070791042](images/1710070791042.png)

扫描器自动生成的意义

- 加快了分析器实现速度
  - 程序员只需在很高的模式层次上描述软件就可以依赖自动生成工具来生成详细的代码
- 修改扫描器的工作变得更加简单
  - 只用修改那些受到影响的模式，无需修改整个程序

### 第四章 语法分析-上

语法分析的主要任务

- 根据给定的文法，识别输入句子的各个成分，从而构造出句子的分析树

大部分语言的语法构造可以用CFG来描述，CFG以token为终结符

大部分语法分析器都期望文法是无二义性的

语法分析的种类

- 自顶向下的分析
  - 从分析树的顶部（根节点）向底部构造分析树
  - 从文法开始符号S推导出串w
- 自底向上的分析
  - 从分析树的底部向顶部构造分析树
  - 将一个串w规约为文法开始符号S
- 上面两种方法只能处理某些文法子类，特别是LL和LR文法，但是其表达能力足以描述现代大部分语法构造

### 4.1 自顶向下的分析

推导的每一步都要做两个选择

- 替换当前句型中的哪个非终结符
- 用该非终结符的哪个候选式进行替换、

最左推导-对应最右规约、最左句型

- 总是选择句型的最左终结符进行替换
- 如果$S\Rightarrow^*_{lm}\alpha$，则称$\alpha$是当前文法的最左句型

最右推导-也称规范推导

- 总是选择句型的最右终结符进行替换
- 如果$S\Rightarrow^*_{rm}\alpha$，则称$\alpha$是当前文法的最右句型
- 在自底向上分析中总是采用最左规约的方式，所以最左规约也称规范规约

最左推导和最右推导具有**唯一性**

自定向下语法分析的通用形式

- 递归下降分析
  - 由一组过程组成，每个过程对应文法的一个非终结符
  - 从文法开始符号S对应的过程开始，其中递归调用文法中其他非终结符对应的过程。如果S对应的过程恰好扫描了整个输入串，则成功完成语法分析

    ![1710292020306](images/1710292020306.png)
  - 存在的问题

    - 同一非终结符的多个候选式存在共同前缀，将导致回溯现象
    - 左递归文法会使递归下降分析器陷入无限循环

左递归文法

    ![1710292117077](images/1710292117077.png)

- 消除直接左递归

  - 将所有形如$A\rightarrow A\alpha|\beta$的产生式由$ A\rightarrow\beta A^`$和$A^`\rightarrow \alpha A^`|\epsilon$替换
  - 事实上就是把左递归换成了右递归
  - 一般形式

    ![1710292479200](images/1710292479200.png)
  - 引进了一些非终结符和空产生式
- 消除间接左递归

  ![1710292703186](images/1710292703186.png)
- 消除左递归的算法

  ![1710292828468](images/1710292828468.png)

提取左公因子

- 通过改写产生式来推迟决定，等读入了足够多的输入，获得足够的信息后再做出正确的选择
- 提取左公因子的算法

  ![1710333282215](images/1710333282215.png)

### 4.2 预测分析法

预测分析是递归下降分析技术的一个特例，通过在输入中向前看固定个数（通常是一个）符号来选择正确的A-产生式

- 可以对某些文法构造出向前看k个输入符号的预测分析器，该类文法也称为LL(k)文法类

预测分析不需要回溯，是一种**确定的**自顶向下分析方法

预测分析法工作过程

- 从文法开始符号触发，在每一部推导过程中根据当前句型的最左非终结符A和当前输入符号a，选择正确的A-产生式。为了保证分析的确定性，选出的候选式必须是唯一的

S_文法：简单的确定性文法

- 每个产生式的右部都以终结符开始
- 同一终结符的各个候选式的首终结符都不同
- S_文法不包含空产生式
- 例

  ![1710335976006](images/1710335976006.png)

什么时候要应用空产生式

- 当前的某终结符A与当前输入符号a不匹配，如果存在A的空产生式，则可以通过检查a是否可以紧跟在A的后面出现，来决定是否使用空产生式

非终结符的后继符号集，FOLLOW集

- 可能在某个句型中紧跟在A后边的终结符a的集合，记为FOLLOW(A)

  - $FOLLOW(A)=\{a|S\Rightarrow^*\alpha Aa\beta,a\in V_T,\alpha,\beta\in(V_T\cup V_N)^*  \}$
- 句型的后面紧跟着输入结束标记$

  - 如果A是某个句型的最右符号，则将$添加到FOLLOW(A)中
- FOLLOW(A)的计算方法

  ![1710337180205](images/1710337180205.png)

串首终结符集，FIRST集

- 串首终结符

  - 串首第一个符号，并且是终结符。简称首终结符
- 给定一个文法符号串a，a的串首终结符集FIRST(a)被定义为可以从a推导得到的串的首终结符构成的集合
- 如果$a\Rightarrow^*\epsilon$，那么$\epsilon$也在FIRST(a)中

  - $\forall \alpha \in (V_T\cup V_N)^+,FIRST(\alpha)=\{a|\alpha\Rightarrow^*a\beta,a\in V_T,\beta\in (V_T\cup V_N)^* \}$
- $FIRST(\alpha)$的计算$\alpha=X_1X_2\dots X_k$

  - $FIRST(\alpha)$![1710336910037](images/1710336910037.png)

    ![1710336925322](images/1710336925322.png)
  - 算法

    ![1710337032359](images/1710337032359.png)
- 计算串$X_1X_2\dots X_k$的FIRST集

  ![1710337077274](images/1710337077274.png)

产生式的可选集，SELECT集

- 指可以用该产生式进行推导时的对应输入符号的集合，记为$SELECT(A\rightarrow\beta)$

  - $SELECT(a\rightarrow a\beta)=\{a\}$
  - $SELECT(A\rightarrow\epsilon )=FOLLOW(A)$
- q_文法

  - 每个产生式的右部或为空，或以终结符开始
  - 具有相同左部的产生式具有不相交的可选集
- 产生式$A\rightarrow \alpha$的可选集

  - $SELECT(A\rightarrow \alpha)=\begin{cases}FIRST(\alpha)&,if \epsilon \notin FIRST(\alpha) \\ (FIRST(\alpha)-\epsilon)\cup FOLLOW(A)&,if\epsilon\in FIRST(\alpha) \end{cases}$

LL(1)文法

- 当且仅当文法G任意两个具有相同左部的产生式$A\rightarrow\alpha|\beta$满足下面条件

  - 不存在非终结符$a$，使得$\alpha,\beta$都能推导出以$a$开头的串
  - $\alpha,\beta$至多有一个能推导出空串
  - $\beta\Rightarrow^*\epsilon,FIRST(\beta)\cap FOLLOW(A)=\empty\\ \alpha\Rightarrow^*\epsilon,FIRST(\alpha)\cap FOLLOW(A)=\empty$
  - 即同一非终结符的各个产生式的可选集互不相交
- 可以为LL(1)文法构造预测分析器

  ![1710337839405](images/1710337839405.png)

如何实现预测分析

- 递归的方式：基于预测分析表对递归下降法进行扩展

  ![1710337960238](images/1710337960238.png)
- 非递归的方式：显式地维护一个栈结构模拟最左推导的过程

  - 表驱动的预测分析法

    ![1710337994638](images/1710337994638.png)
- 二者对比

  ![1710338013985](images/1710338013985.png)

预测分析的实现步骤

1. 构造文法
2. 改造文法：消除二义性、消除左递归、消除回溯
3. 求每个变量的FIRST集和FOLLOW集，求得每个候选式得SELECT集
4. 检查是否为LL(1)文法。若是，构造预测分析表
5. 对于递归的预测分析，根据预测分析表为每个非终结符编写一个过程；对于非递归的预测分析，实现表驱动的预测分析算法

预测分析中的错误检测-两种情况下可以检测到错误

- 栈顶符号和当前输入的符号不匹配
- 栈顶非终结符与当前输入符号在预测分析表对应项信息为空

预测分析中的错误恢复-恐慌模式

- 忽略输入中的一些符号，直到输入中出现由设计者选定的同步词法单元集合中的某个词法单元

  - 其效果依赖于同步集合的选取。集合的选取应该使得语法分析器能从实际遇到的错误中快速恢复
    - 例如可以将FOLLOW(A)中的所有终结符放入非终结符A的同步记号集合
- 如果终结符在栈顶而不能匹配，最简单的方法是弹出此终结符

  ![1710338392563](images/1710338392563.png)
